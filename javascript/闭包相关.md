# 闭包作用域
1.创建函数
- 开辟一个堆内存
- 把函数体中的代码当作字符串存储进去
- 把堆内存的地址赋值给函数名/变量名
- 函数在哪创建,那么它执行时候所需要的查找的上级作用域就是谁

2.函数执行
- 形成一个全新的私有作用域，执行上下文，私有栈内存(执行一次形成一个，多个之间也不会产生影响)
- 形参赋值&变量提升
- 代码执行(把所属堆内存中的代码字符串拿出来一行一行的执行)
- 遇到一个变量，首先看它是否为私有变量(形参和在私有作用域中声明的变量是私有变量)，是私有的就操作自己的变量即可,不是私有的则向上级作用域中查找...一直到全局作用域为止 => 作用域链查找机制
- 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了,这种机制其实就是 闭包的保护机制

3.关于堆栈内存释放问题
- 函数执行就会形成栈内存(从内存中分配的一块空间),如果内存都不销毁释放,很容易就会导致栈内存溢出

`堆内存释放`
- 如果当前创建的堆内存不被其它东西所占用(浏览器会在空闲的时候查找每一个内存的引用情况,不被占用的都会给回收释放掉)

`栈内存释放`
- 打开浏览器形成的全局作用域是栈内存
- 手动执行函数形成的私有作用域是栈内存
- 基于ES6中的LET/CONST形成的块级作用域也是栈内存

  全局栈内存:关掉页面的时候才会销毁

  私有栈内存：
    - 一般情况下，函数执行完毕，形成的私有栈内存就会被销毁
    - 但是一旦私有栈内存中的某个东西(一般都是堆地址)被私有作用域以外的事物给占用了,则当前栈内存不能立即被释放销毁(`特点:私有作用域中的私有变量等信息也保留下来了`)=>`市面上人为的闭包:函数执行形成不能被释放的私有栈内存,这样才是闭包`

# 闭包的两个作用
    从性能角度讲,我们真实项目中应该减少对闭包的使用(因为闭包会产生不释放的栈内存,过多使用容易导致内存溢出或者性能降低)
- 保护
  - 防止变量污染
- 保存


```js
//练习题
var i = 5
function fn(i){
  return function(n) {
    console.log(n + (++i))
  }
}
var f = fn(1)
f(2); //4
fn(3)(4); //8
fn(5)(6);//12
f(7);//10
console.log(i)// 5
```

```js
var i = 20;
function fn() {
  i -= 2;
  return function(n){
    console.log((++i)-n)
  }
}
var f = fn(); //i =18
f(1); // i = 19    log= 18
f(2); // i = 20    log= 18
fn()(3); // i = 19    log= 16
fn()(4); // i = 18    log= 14
f(5); // i = 19    log= 14
console.log(i) // i = 19
```
```js
var n = 0;
function a(){
  var n = 10;
  function b(){
    n++;
    console.log(n)
  }
  b();
  return b;
}
var c =a() //内部 n = 11 log 11
c(); // 内部n=12 log 12
console.log(n) //0
```

```js
var a = 9;
function fn(){
  a = 0;
  return function(b){
    return b+a++;
  }
}
var f = fn(); a = 0
console.log(f(5)); // 5  a=1
console.log(fn()(5)); // 5 a=1
console.log(f(5)); //6 a = 2
console.log(a) //2
```

```js
function fn(i){
  return function(n){
    console.log(n + (i++));
  }
}
var f = fn(10); //
f(20); // i = 11; 30
fn(20)(40);// i= 21; 60
fn(30)(50);// i=31; 80
f(30); // i=12; 41
```
```js
var test = (function(i){
  return function() {
    alert(i *= 2)
  }
})(2)
test(5)
```
